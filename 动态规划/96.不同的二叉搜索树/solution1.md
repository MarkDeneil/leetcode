dp\[i]:1 到 i 为节点组成的二叉搜索树的个数为 dp\[i]。（在下面的解释中其实指的是 连续 i 个数组成的二叉搜索树，这连续的 i 个数不一定从 1 开始    
递推公式的推导：  
![20210107093129889](https://user-images.githubusercontent.com/83362131/219406668-c69a53d6-6bf9-4258-b256-71b8a3bd2fc9.png)
![20210107093226241](https://user-images.githubusercontent.com/83362131/219406748-68c93e8b-d01b-445f-8635-6a13b8c8d293.png)
dp\[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量  
元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量  
元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量  
元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量   
有2个元素的搜索树数量就是dp\[2]。  
有1个元素的搜索树数量就是dp\[1]。  
有0个元素的搜索树数量就是dp\[0]。  
所以dp\[3] = dp\[2] * dp\[0] + dp\[1] * dp\[1] + dp\[0] * dp\[2]  
注意，在图 1 的最左侧，以 1 为头节点的二叉搜索数的右子树 dp\[2] 其实是以 2 开头的，节点数为 2 的二叉搜索树，并不是从 1 到 2 的二叉搜索树，这也是本题 dp\[i] 的概念：连续 i 个数组成的二叉搜索树，这连续的 i 个数不一定从 1 开始  
```cpp
class Solution {
public:
    int numTrees(int n) {
        // 这里只要注意一点，{1，2} 两个结点的排列和 {2，3} 两个结点的排列是一样的
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                dp[i] += dp[j] * dp[i-j-1]; 
            }
        }
        return dp[n];
    }
};
```
