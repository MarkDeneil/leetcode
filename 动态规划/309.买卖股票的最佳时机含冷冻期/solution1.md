状态设置：  
dp[i][0] 持有股票能获得的最大利润  
dp[i][1] 保持卖出股票的状态（不包含冷冻期，不包含卖出股票当天）能获得的最大利润  
dp[i][2] 卖出股票当天  
dp[i][3] 冷冻期当天  
各个状态推导：  
dp[i][0]：
若第 i-1 天持有股票：继续保持状态 dp[i-1][0]  
若第 i-1 天是保持卖出股票的状态，则今天买入 dp[i-1][1] - prices[i]  
dp[i][1]：  
若第 i-1 天也是保持卖出股票状态，则继续保持 dp[i-1][1]   
// 若第 i-1 天是卖出股票当天  dp[i-1][2]  这一条错误，若前一天是卖出股票当天，则今天应该是冷冻期状态  
若第 i-1 天是冷冻期当天 dp[i-1][3]  
dp[i][2]：  
第 i-1 天只能持有股票 dp[i-1][1] + prices[i]  
dp[i][3]：  
第 i-1 天只能是卖出股票当天  dp[i-1][2]  
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 不同于 123.买卖股票的最佳时机III 和 188.买卖股票的最佳时机IV 题目中没有具体说明多少笔交易，因此不需要设置 dp[i][0] 表示一直未交易的状态,然后再设置第一次持有，第一次不持有，第二次持有，第二次不持有。。。
        // 分成四个状态：
        // dp[i][0]：持有股票状态
        // dp[i][1]：保持不持有股票状态（不包含卖出股票当天，以及冷冻期当天）
        // dp[i][2]：卖出股票当天
        // dp[i][3]：冷冻期当天
        vector<vector<int>> dp(prices.size(), vector<int>(4, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        dp[0][3] = 0;
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i])); // 继续保持持有股票状态；保持不持有股票状态后今天买入；昨天是冷冻期今天买入
            dp[i][1] = max(dp[i-1][1], dp[i-1][3]); // 继续保持不持有股票状态；或者昨天是冷冻期，今天仍然不买入变为保持不持有股票状态
            dp[i][2] = dp[i-1][0] + prices[i]; // 今天是卖出股票当天，昨天只能是持有股票状态
            dp[i][3] = dp[i-1][2]; // 今天是冷冻期当天，昨天只能是卖出股票当天
        }
        return max(dp[prices.size()-1][1], max(dp[prices.size()-1][2], dp[prices.size()-1][3]));
    }
};
```
