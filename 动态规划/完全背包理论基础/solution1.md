完全背包中，与 01 背包不同的是，每个物品都可以选择无限次数。  
求能装得下的最大容量。
因为可以选择无限次数，因此完全背包的**滚动数组形式**中容量 j 的遍历需要从小到大遍历，因此内层循环变为：  
```cpp
// 先遍历物品，再遍历背包容量
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量，正序遍历
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```
即下图中容量 j 正序遍历的情况，当 j 等于 2 时，物品 0 被重复放入两次：  
![IMG_0381(20230222-231807)](https://user-images.githubusercontent.com/83362131/220674493-2d352f25-7c4b-4c13-af1c-49525b73c8a5.PNG)
![20210126104510106](https://user-images.githubusercontent.com/83362131/220674525-c7ffd369-d206-430d-b7eb-87afa25aec35.jpg)

在完全背包问题中，求能装得下的最大容量时，先遍历物品还是先遍历背包容量都是可以的。  
完全背包中，除了问背包能装得下的最大价值这种问题外，还有其他的问题形式，如求可以凑成总金额的物品的组合数，排列数等。  
类似`518.零钱兑换II`题目。  
这种情况下，就涉及完全背包是先遍历物品，还是先遍历背包容量的问题：  
在完全背包的**滚动数组形式**中，两层 for 循环的顺序是否可以颠倒？（非滚动数组形式也类似）  
**可以颠倒，求出排列和组合两种不同的结果**。  
```
// 先遍历背包容量，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
    cout << endl;
}
```
**如果求组合数就是外层for循环遍历物品，内层for遍历背包。**（如物品集合 {1,2} 就是组合数）  
**如果求排列数就是外层for遍历背包，内层for循环遍历物品。**（如物品集合 {1,2},{2,1} 是排列数）  
解释：  
先遍历物品后遍历背包是这样，比如，外层循环固定物品【1】，在内层循环遍历背包时，随着背包不断增加，coins【1】可以重复被添加进来，而由于外层循环固定了，因此物品【2】只能在下一次外层循环添加进不同大小的背包中，这么看的话，物品【i+1】只能在coins【i】之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加物品【2】的基础上还能再添加物品【1】的情况，那么就有了物品【1】在物品【2】之后的情况了。  
