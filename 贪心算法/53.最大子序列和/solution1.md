思路：  
局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。  
为什么可以用上面的这种思路做：（见代码随想录误区2）：  
**因为和为3，只要连续和还是正数就会 对后面的元素 起到增大总和的作用。 所以只要连续和为正数我们就保留**。  
这里也会有录友疑惑，那 4 + -1 之后 不就变小了吗？ 会不会错过 4 成为最大连续和的可能性？   
其实并不会，因为还有一个变量result 一直在更新 最大的连续和，只要有更大的连续和出现，result就更新了，那么result已经把4更新了，后面 连续和变成3，也不会对最后结果有影响。  
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
        // 可以这样考虑：当前面的局部和为 负 时，将局部和置为0，从当前元素开始重新算局部和，这种情况是很自然的
        // 当前面的局部和为正时，前面的局部和加上当前元素一定大于当前元素，因此此时的局部和比从当前元素开始重新算局部和一定要大，所以不需要重新从当前元素算局部和，见代码随想录 误区2 解释
        int res = INT32_MIN;
        int sum = 0;
        for (int i = 0; i < nums.size(); ++i) {
            sum += nums[i];
            if (sum > res) 
                res = sum;
            if (sum < 0)
                sum = 0;
        }
        return res;
    }
};
```
